(window.webpackJsonp=window.webpackJsonp||[]).push([["chunk-2d0c8e12"],{5782:function(e,t,r){"use strict";function a(e,t){Object.defineProperty(e,"name",{value:t})}function o(e,{Static:t,Method:r,depends:o=[]}){const i=(i=Promise,s=!1)=>{o.forEach(e=>{l[e](i)}),r&&(a(r,"name"),i.prototype[e]&&!s||(i.prototype[e]=r)),t&&(i[e]&&!s||(a(t,e),i[e]=t),i.prototype[e]||(i.prototype[e]=function(...t){return this.constructor[e](this,...t)},a(i.prototype[e],e)))};return l[e]=i,i}function i(e,t,r){return n[e]||(n[e]=class extends Error{constructor(t,r){var a;super(t),this.name=e,this.args=r,(null==r||null===(a=r.err)||void 0===a?void 0:a.stack)&&(this.stack+="\n  From Previous Error:\n"+r.err.stack)}}),new n[e](t,r)}Object.defineProperty(t,"__esModule",{value:!0}),t.promiseHelpers=function(e=Promise){for(const t in l)l[t](e)},t.wrapper=o,t.errors=t.functions=void 0;const s=Symbol("PromiseDelay");let l={};t.functions=l,o("resolvePromise",{Static(e){return this.resolve(e).then(e=>"function"==typeof e?e():e)}}),o("delay",{Static(e=100,t){return this.resolvePromise(t).then(t=>new this(r=>{setTimeout(r,e,t)}))},Method(e=100){const t=this.constructor;return this.then(r=>t.delay(e,r))},depends:["resolvePromise"]}),o("atLeast",{Static(e,t=100){return this.resolve(this.all([this.resolvePromise(e),this.delay(t)]).get(0))},depends:["get","delay","resolvePromise"]}),o("timeout",{Static(e,t,r){if("number"!=typeof t)throw i("PromiseTimeoutError","time is not a number");return this.race([this.resolvePromise(e),this.delay(t).then(()=>{throw"function"==typeof(null==e?void 0:e.cancel)&&e.cancel(),i("PromiseTimeoutError",r||`Promise timeout in ${t}ms`,{time:t})})])},depends:["delay","resolvePromise"]}),o("timeoutDefault",{async Static(e,t=100,r,a=!1){if(void 0===r)throw i("PromiseTimeoutDefaultError","there is no default for timeoutDefault");try{return await this.timeout(e,t)}catch(o){if("PromiseTimeoutError"===o.name||a)return r;throw o}},depends:["timeout"]}),o("attachTimers",{Static(e,{delay:t,atLeast:r,timeout:a}={}){if(r&&a&&r>=a)throw i("PromiseTimersCoherenceError","timeout must be greather than atLeast",{delay:t,atLeast:r,timeout:a});return e=this.resolvePromise(e),r&&e.atLeast(r),a&&e.timeout(a),t&&e.delay(t),e},depends:["delay","atLeast","timeout","resolvePromise"]}),o("map",{async Static(e,t,{catchError:r=!0,parallel:a=!0,delay:o,atLeast:s,timeout:l}={}){const n=[];let c=0;try{if(!(e=await this.resolvePromise(e))[Symbol.iterator])throw i("PromiseIterableError","trying to use map without an iterable object",{iterable:e});for(let i of e)try{i=await i;let r=this.resolve(t(i,c,e)).then(e=>this.attachTimers(e,{delay:o,atLeast:s,timeout:l}));a?n.push(r):n.push(await r)}catch(u){if(r)throw c--,u;n.push(u)}finally{c++}}catch(u){if("PromiseIterableError"===u.name)throw u;throw i("PromiseMapError","some callback or iterator throws an error ",{iterable:e,id:c,result:n,err:u})}return a?this.all(n):n},depends:["attachTimers","resolvePromise"]}),o("forEach",{async Static(e,t,{parallel:r=!0,delay:a,atLeast:o,timeout:s}={}){try{await this.map(e,t,{catchError:!0,parallel:r,delay:a,atLeast:o,timeout:s})}catch(l){if("PromiseMapError"===l.name){const{iterable:e,id:t,err:r}=l.args;throw i("PromiseForEachError","some callback or iterable throws error",{iterable:e,id:t,err:r})}throw l}},depends:["map"]}),o("sequence",{async Static(e,t={}){const r=e=>"number"==typeof e?this.delay(e,s):e();try{return(await this.map(e,r,{parallel:!1,...t})).reduce((e,t)=>(t!==s&&e.push(t),e),[])}catch(a){if("PromiseMapError"===a.name){const{iterable:e,id:t,result:r,err:o}=a.args;throw i("PromiseSequenceError","some callback or iterable throws error",{iterable:e,id:t,result:r,err:o})}throw a}},depends:["map","delay"]}),o("sequenceAllSettled",{async Static(e,t={}){const r=async e=>{if("number"==typeof e)return this.delay(e,s);try{let t=this.resolve(e());return{status:"fulfilled",value:await t}}catch(t){return{status:"rejected",reason:t}}};try{return(await this.map(e,r,{...t,parallel:!1})).reduce((e,t)=>(t!==s&&e.push(t),e),[])}catch(a){if("PromiseMapError"===a.name){const{iterable:e,id:t,result:r,err:o}=a.args;throw i("PromiseSequenceError","some callback or iterable throws error",{iterable:e,id:t,result:r,err:o})}throw a}},depends:["map","delay"]}),o("reduce",{async Static(e,t,r,{delay:a,atLeast:o,timeout:s}={}){let l,n,c=0;try{if(l=await r,!(e=await e)[Symbol.iterator])throw i("PromiseIterableError","trying to use reduce without an iterable object",{iterable:e});n=l;for await(const r of e)n=l,l=this.resolve(t(l,r,c,e)).attachTimers({delay:a,atLeast:o,timeout:s}),l=await l,n=l,c++}catch(u){if("PromiseIterableError"===u.name)throw u;throw i("PromiseReduceError","some iterable throws error",{lastResult:n,id:c,err:u,iterable:e})}return l},depends:["attachTimers"]}),o("waterfall",{async Static(e,t,r){const a=(e,t)=>"number"==typeof t?this.delay(t,e):t(e);try{return await this.reduce(e,a,t,r)}catch(o){if("PromiseReduceError"===o.name){const{iterable:e,id:t,lastResult:r,err:a}=o.args;throw i("PromiseWaterfallError","some callback or iterable throws error",{iterable:e,id:t,lastResult:r,err:a})}throw o}},depends:["reduce"]}),o("get",{async Static(e,t){const r=await e;if(t=await t,"object"!=typeof r)throw i("PromiseNotObject","fulfilled promise is not an object",{result:r,key:t});if(t in r)return r[t];throw i("PromiseKeyNotFound",`key ${t} not found`,{result:r,key:t})}}),o("keys",{async Static(e){const t=await e;if("object"!=typeof t)throw i("PromiseNotObject","fulfilled promise is not an object",{result:t});return Object.keys(await e)}}),o("call",{async Method(e,...t){const r=await(this);if("function"!=typeof r)throw i("PromiseCallableError","resulting promise is not a function",{result:r,thisObj:e,args:t});return r.call(e,...t)}}),o("apply",{async Method(e,t){const r=await(this);if("function"!=typeof r)throw i("PromiseCallableError","resulting promise is not a function",{result:r,thisObj:e,args:t});return r.apply(e,t)}}),o("exec",{async Method(...e){const t=await(this);if("function"!=typeof t)throw i("PromiseCallableError","resulting promise is not a function",{result:t,args:e});return t(...e)}}),o("waitForKey",{async Static(e,t,{ellapsed:r=100,maxIterations:a=1e4}={}){try{return await this.resolvePromise(e).get(t)}catch(o){if("PromiseKeyNotFound"===o.name){if(--a<0)throw i("PromiseMaxIterationsError","Max iterations have been reached");return await this.delay(r),this.waitForKey(e,t,{ellapsed:r,maxIterations:a})}throw o}},depends:["delay","get","resolvePromise"]}),o("waitForResult",{async Static(e,{ellapsed:t=100,delay:r,atLeast:a,maxIterations:o=1e4,retry:s=!0,timeout:l}={},n=[]){Array.isArray(n)||(n=[n]);try{n=await this.all(n),e=await e;let c=this.resolve(e(...n)).attachTimers({delay:r,atLeast:a,timeout:l});if(c=await c,void 0!==c)return c;if(--o<0)throw i("PromiseMaxIterationsError","Max iterations have been reached");return await this.delay(t),this.waitForResult(e,{ellapsed:t,delay:r,atLeast:a,maxIterations:o,retry:s},n)}catch(c){if("PromiseMaxIterationsError"===c.name)throw c;if(s)return this.waitForResult(e,{ellapsed:t,delay:r,atLeast:a,maxIterations:o,retry:s,timeout:l},n);throw c}},depends:["delay","attachTimers"]});const n={};t.errors=n}}]);